import MockAdapter from 'axios-mock-adapter';
import { 
  mockUsers, 
  mockUserRoles,
  mockTables, 
  mockReservations,
  mockOrders,
  mockMenuItems
} from '../mocks/data';

/**
 * G√©n√®re un token JWT factice mais valide pour les mocks
 */
const generateValidMockToken = (userId) => {
  // Header JWT
  const header = {
    "alg": "HS256",
    "typ": "JWT"
  };

  // Payload JWT avec expiration dans 24h
  const payload = {
    "sub": userId,
    "iat": Math.floor(Date.now() / 1000),
    "exp": Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24h
    "mock": true,
    "role": mockUsers.find(u => u.id === userId)?.role || 'guest'
  };

  // Simuler l'encodage base64 d'un JWT
  const encodedHeader = btoa(JSON.stringify(header));
  const encodedPayload = btoa(JSON.stringify(payload));
  const fakeSignature = btoa(`mock-signature-${userId}-${Date.now()}`);

  return `${encodedHeader}.${encodedPayload}.${fakeSignature}`;
};

/**
 * Configuration d'un adaptateur mock pour Axios avec logging am√©lior√©
 */
const setupMock = (axiosInstance) => {
  console.log('üé≠ Configuration du MockAdapter...');
  
  try {
    // Cr√©ation d'une nouvelle instance de MockAdapter
    const mock = new MockAdapter(axiosInstance, { 
      delayResponse: 300, // D√©lai r√©duit pour le d√©veloppement
      onNoMatch: "throwException" // Lever une exception si aucune route n'est trouv√©e
    });

    console.log('üìã Configuration des routes mock...');

    // ========== AUTHENTIFICATION ==========
    
    // Login
    mock.onPost('/auth/login').reply((_config) => {
      console.log('üîê Mock: Tentative de connexion');
      
      try {
        const { email, password } = JSON.parse(config.data);
        console.log(`üë§ Tentative de connexion pour: ${email}`);
        
        // Recherche de l'utilisateur
        const user = mockUsers.find(u => u.email === email);
        
        if (!user || user.password !== password) {
          console.log('‚ùå Mock: √âchec de l\'authentification');
          return [401, { message: 'Email ou mot de passe incorrect' }];
        }
        
        // Ne pas envoyer le mot de passe dans la r√©ponse
        const { password: _, ...userWithoutPassword } = user;
        
        // G√©n√©rer un token JWT valide
        const validToken = generateValidMockToken(user.id);
        
        console.log(`‚úÖ Mock: Connexion r√©ussie pour ${user.firstName} ${user.lastName} (${user.role})`);
        console.log(`üé´ Token g√©n√©r√©: ${validToken.substring(0, 50)}...`);
        
        return [200, {
          user: userWithoutPassword,
          token: validToken
        }];
      } catch (_error) {
        console.error('‚ùå Mock: Erreur lors du parsing des donn√©es de login:', error);
        return [400, { message: 'Donn√©es invalides' }];
      }
    });
    
    // Register
    mock.onPost('/auth/register').reply((_config) => {
      console.log('üìù Mock: Tentative d\'inscription');
      
      try {
        const userData = JSON.parse(config.data);
        
        // V√©rification si l'email existe d√©j√†
        if (mockUsers.some(u => u.email === userData.email)) {
          console.log('‚ùå Mock: Email d√©j√† utilis√©');
          return [400, { message: 'Cet email est d√©j√† utilis√©' }];
        }
        
        // Cr√©ation d'un nouvel utilisateur
        const newUser = {
          id: `user-${mockUsers.length + 1}`,
          ...userData,
          createdAt: new Date().toISOString()
        };
        
        // Ajout de l'utilisateur au mock (uniquement pour la session)
        mockUsers.push(newUser);
        
        console.log(`‚úÖ Mock: Inscription r√©ussie pour ${newUser.email}`);
        return [201, { message: 'Inscription r√©ussie' }];
      } catch (_error) {
        console.error('‚ùå Mock: Erreur lors de l\'inscription:', error);
        return [400, { message: 'Donn√©es invalides' }];
      }
    });
    
    // R√©cup√©ration des donn√©es utilisateur
    mock.onGet('/auth/me').reply((_config) => {
      console.log('üë§ Mock: R√©cup√©ration des donn√©es utilisateur');
      
      // Extraire le token de l'en-t√™te Authorization
      const authHeader = config.headers.Authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        console.log('‚ùå Mock: Token manquant ou invalide');
        return [401, { message: 'Token d\'authentification requis' }];
      }
      
      const token = authHeader.substring(7); // Enlever "Bearer "
      
      try {
        // D√©coder le payload du token JWT mock
        const parts = token.split('.');
        if (parts.length !== 3) {
          console.log('‚ùå Mock: Format de token invalide');
          return [401, { message: 'Token invalide' }];
        }
        
        const payload = JSON.parse(atob(parts[1]));
        const userId = payload.sub;
        
        // Trouver l'utilisateur correspondant
        const user = mockUsers.find(u => u.id === userId);
        if (!user) {
          console.log('‚ùå Mock: Utilisateur non trouv√©');
          return [401, { message: 'Utilisateur non trouv√©' }];
        }
        
        // V√©rifier l'expiration du token
        const currentTime = Math.floor(Date.now() / 1000);
        if (payload.exp < currentTime) {
          console.log('‚ùå Mock: Token expir√©');
          return [401, { message: 'Token expir√©' }];
        }
        
        const { password: _, ...userWithoutPassword } = user;
        console.log(`‚úÖ Mock: Donn√©es utilisateur r√©cup√©r√©es pour ${userWithoutPassword.firstName}`);
        return [200, userWithoutPassword];
        
      } catch (_error) {
        console.error('‚ùå Mock: Erreur lors du d√©codage du token:', error);
        return [401, { message: 'Token invalide' }];
      }
    });
    
    // Logout
    mock.onPost('/auth/logout').reply((_config) => {
      console.log('üö™ Mock: D√©connexion');
      return [200, { message: 'D√©connexion r√©ussie' }];
    });

    // ========== ROLES UTILISATEURS ==========
    
    mock.onGet('/user-roles').reply((_config) => {
      console.log('üè∑Ô∏è Mock: R√©cup√©ration des r√¥les utilisateurs');
      return [200, mockUserRoles];
    });
    
    // R√©cup√©ration d'un r√¥le sp√©cifique
    mock.onGet(/\/user-roles\/\w+/).reply((_config) => {
      const roleId = config.url.split('/').pop();
      console.log(`üè∑Ô∏è Mock: R√©cup√©ration du r√¥le ${roleId}`);
      
      const role = mockUserRoles.find(r => r.id === roleId);
      
      if (!role) {
        console.log(`‚ùå Mock: R√¥le ${roleId} non trouv√©`);
        return [404, { message: 'R√¥le non trouv√©' }];
      }
      
      return [200, role];
    });

    // ========== FLOOR PLANS ==========
    
    // Donn√©es fictives pour les plans de salle avec tokens valides
    const mockFloorPlans = [
      {
        id: '1',
        name: 'Salle principale',
        description: 'Rez-de-chauss√©e, 20 tables',
        tables: [
          {
            id: '101',
            label: 'Table 1',
            capacity: 4,
            shape: 'rectangle',
            color: '#3498db',
            x: 100,
            y: 100,
            width: 80,
            height: 80,
            rotation: 0
          },
          {
            id: '102',
            label: 'Table 2',
            capacity: 2,
            shape: 'circle',
            color: '#e74c3c',
            x: 250,
            y: 120,
            width: 60,
            height: 60,
            rotation: 0
          },
          {
            id: '103',
            label: 'Table 3',
            capacity: 6,
            shape: 'rectangle',
            color: '#2ecc71',
            x: 150,
            y: 250,
            width: 120,
            height: 80,
            rotation: 0
          }
        ],
        obstacles: [],
        perimeter: [],
        capacityLimit: 50
      },
      {
        id: '2',
        name: 'Terrasse',
        description: 'Ext√©rieur, 8 tables',
        tables: [
          {
            id: '201',
            label: 'Terrasse 1',
            capacity: 4,
            shape: 'circle',
            color: '#f39c12',
            x: 80,
            y: 80,
            width: 70,
            height: 70,
            rotation: 0
          },
          {
            id: '202',
            label: 'Terrasse 2',
            capacity: 4,
            shape: 'circle',
            color: '#f39c12',
            x: 200,
            y: 80,
            width: 70,
            height: 70,
            rotation: 0
          }
        ],
        obstacles: [],
        perimeter: [],
        capacityLimit: 32
      }
    ];

    // GET /floor-plans - R√©cup√©ration de tous les plans
    mock.onGet('/floor-plans').reply((_config) => {
      console.log('üèóÔ∏è Mock: R√©cup√©ration des plans de salle');
      return [200, mockFloorPlans];
    });

    // GET /floor-plans/:id - R√©cup√©ration d'un plan sp√©cifique
    mock.onGet(/\/floor-plans\/\w+/).reply((_config) => {
      const id = config.url.split('/').pop();
      console.log(`üèóÔ∏è Mock: R√©cup√©ration du plan ${id}`);
      
      const floorPlan = mockFloorPlans.find(plan => plan.id === id);
      
      if (!floorPlan) {
        console.log(`‚ùå Mock: Plan ${id} non trouv√©`);
        return [404, { message: 'Plan de salle non trouv√©' }];
      }
      
      return [200, floorPlan];
    });

    // POST /floor-plans - Cr√©ation d'un nouveau plan
    mock.onPost('/floor-plans').reply((_config) => {
      console.log('üèóÔ∏è Mock: Cr√©ation d\'un nouveau plan');
      
      try {
        const floorPlanData = JSON.parse(config.data);
        
        const newFloorPlan = {
          id: Date.now().toString(),
          ...floorPlanData,
          tables: floorPlanData.tables || [],
          obstacles: floorPlanData.obstacles || [],
          perimeter: floorPlanData.perimeter || [],
          capacityLimit: floorPlanData.capacityLimit || 50
        };
        
        console.log(`‚úÖ Mock: Plan cr√©√© avec l'ID ${newFloorPlan.id}`);
        return [201, newFloorPlan];
      } catch (_error) {
        console.error('‚ùå Mock: Erreur lors de la cr√©ation du plan:', error);
        return [400, { message: 'Donn√©es invalides' }];
      }
    });

    // PUT /floor-plans/:id - Mise √† jour d'un plan
    mock.onPut(/\/floor-plans\/\w+/).reply((_config) => {
      const id = config.url.split('/').pop();
      console.log(`üèóÔ∏è Mock: Mise √† jour du plan ${id}`);
      
      try {
        const updatedData = JSON.parse(config.data);
        
        const floorPlanIndex = mockFloorPlans.findIndex(plan => plan.id === id);
        
        if (floorPlanIndex === -1) {
          console.log(`‚ùå Mock: Plan ${id} non trouv√© pour mise √† jour`);
          return [404, { message: 'Plan de salle non trouv√©' }];
        }
        
        const updatedFloorPlan = {
          ...mockFloorPlans[floorPlanIndex],
          ...updatedData,
          id // Pr√©server l'ID d'origine
        };
        
        console.log(`‚úÖ Mock: Plan ${id} mis √† jour`);
        return [200, updatedFloorPlan];
      } catch (_error) {
        console.error('‚ùå Mock: Erreur lors de la mise √† jour:', error);
        return [400, { message: 'Donn√©es invalides' }];
      }
    });

    // DELETE /floor-plans/:id - Suppression d'un plan
    mock.onDelete(/\/floor-plans\/\w+/).reply((_config) => {
      const id = config.url.split('/').pop();
      console.log(`üèóÔ∏è Mock: Suppression du plan ${id}`);
      
      const floorPlanIndex = mockFloorPlans.findIndex(plan => plan.id === id);
      
      if (floorPlanIndex === -1) {
        console.log(`‚ùå Mock: Plan ${id} non trouv√© pour suppression`);
        return [404, { message: 'Plan de salle non trouv√©' }];
      }
      
      console.log(`‚úÖ Mock: Plan ${id} supprim√©`);
      return [200, { id }];
    });

    // ========== AUTRES ROUTES ==========
    
    // Tables
    mock.onGet('/tables').reply((_config) => {
      console.log('ü™ë Mock: R√©cup√©ration des tables');
      return [200, mockTables];
    });
    
    // R√©servations
    mock.onGet('/reservations').reply((_config) => {
      console.log('üìÖ Mock: R√©cup√©ration des r√©servations');
      console.log('üìã Param√®tres de la requ√™te:', config.params);
      
      // Gestion des filtres optionnels
      let filteredReservations = [...mockReservations];
      
      if (config.params) {
        if (config.params.date) {
          filteredReservations = filteredReservations.filter(r => 
            r.date.startsWith(config.params.date)
          );
        }
        if (config.params.status) {
          filteredReservations = filteredReservations.filter(r => 
            r.status === config.params.status
          );
        }
      }
      
      return [200, filteredReservations];
    });
    
    // Commandes
    mock.onGet('/orders').reply((_config) => {
      console.log('üçΩÔ∏è Mock: R√©cup√©ration des commandes');
      return [200, mockOrders];
    });
    
    // Menu items
    mock.onGet('/menu-items').reply((_config) => {
      console.log('üìã Mock: R√©cup√©ration du menu');
      return [200, mockMenuItems];
    });

    // Gestion des routes non mock√©es
    mock.onAny().reply((_config) => {
      console.warn(`‚ö†Ô∏è Mock: Route non trouv√©e: ${config.method?.toUpperCase()} ${config.url}`);
      return [404, { message: `Route non trouv√©e: ${config.method?.toUpperCase()} ${config.url}` }];
    });

    console.log('‚úÖ MockAdapter configur√© avec succ√®s');
    console.log('üìä Routes mock√©es disponibles:');
    console.log('  - POST /auth/login (avec tokens JWT valides)');
    console.log('  - POST /auth/register');
    console.log('  - GET  /auth/me');
    console.log('  - POST /auth/logout');
    console.log('  - GET  /user-roles');
    console.log('  - GET  /floor-plans');
    console.log('  - POST /floor-plans');
    console.log('  - PUT  /floor-plans/:id');
    console.log('  - DELETE /floor-plans/:id');
    console.log('  - GET  /tables');
    console.log('  - GET  /reservations');
    console.log('  - GET  /orders');
    console.log('  - GET  /menu-items');

  } catch (_error) {
    console.error('‚ùå Erreur lors de la configuration du MockAdapter:', error);
    throw error;
  }
};

export default setupMock;
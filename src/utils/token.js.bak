import {jwtDecode} from 'jwt-decode';

// RÃ©cupÃ©rer le token depuis le localStorage
export const getToken = () => {
  return localStorage.getItem('token');
};

// Enregistrer le token dans le localStorage
export const setToken = (token) => {
  localStorage.setItem('token', token);
};

// Supprimer le token du localStorage
export const removeToken = () => {
  localStorage.removeItem('token');
};

// VÃ©rifier si c'est un token de mock (pour le dÃ©veloppement)
const isMockToken = (token) => {
  return token && token.startsWith('mock-jwt-token-');
};

// CrÃ©er un token JWT factice valide pour les mocks
const createValidMockToken = (userId) => {
  // CrÃ©er un header JWT basique
  const header = {
    "alg": "HS256",
    "typ": "JWT"
  };

  // CrÃ©er un payload JWT avec expiration dans 24h
  const payload = {
    "sub": userId,
    "iat": Math.floor(Date.now() / 1000),
    "exp": Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24h
    "mock": true
  };

  // Encoder en base64 (simulation d'un vrai JWT)
  const encodedHeader = btoa(JSON.stringify(header));
  const encodedPayload = btoa(JSON.stringify(payload));
  const fakeSignature = btoa(`mock-signature-${userId}`);

  return `${encodedHeader}.${encodedPayload}.${fakeSignature}`;
};

// VÃ©rifier si le token est valide (non expirÃ©)
export const isTokenValid = () => {
  const token = getToken();
  if (!token) return false;

  try {
    // Gestion spÃ©ciale pour les anciens tokens de mock mal formÃ©s
    if (isMockToken(token)) {
      console.log('ğŸ­ DÃ©tection d\'un ancien token de mock, conversion en cours...');
      
      // Extraire l'ID utilisateur de l'ancien token
      const parts = token.split('-');
      const userId = parts.length > 3 ? parts[3] : 'user-1';
      
      // CrÃ©er un nouveau token valide et le sauvegarder
      const newValidToken = createValidMockToken(userId);
      setToken(newValidToken);
      
      console.log('âœ… Token de mock converti avec succÃ¨s');
      return true;
    }

    // DÃ©coder le token JWT normal
    const decoded = jwtDecode(token);
    const currentTime = Date.now() / 1000;
    
    // VÃ©rification de l'expiration du token
    const isValid = decoded.exp > currentTime;
    
    if (!isValid) {
      console.log('âŒ Token expirÃ©, suppression...');
      removeToken();
    }
    
    return isValid;
  } catch (_error) {
    console.error('âŒ Erreur lors de la vÃ©rification du token:', error);
    console.log('ğŸ§¹ Nettoyage du token invalide...');
    
    // Supprimer le token invalide
    removeToken();
    return false;
  }
};

// DÃ©coder le token pour rÃ©cupÃ©rer ses informations
export const getDecodedToken = () => {
  const token = getToken();
  if (!token) return null;

  try {
    // Gestion spÃ©ciale pour les tokens de mock mal formÃ©s
    if (isMockToken(token)) {
      // Convertir d'abord le token
      if (isTokenValid()) {
        // RÃ©cupÃ©rer le nouveau token converti
        const newToken = getToken();
        return jwtDecode(newToken);
      }
      return null;
    }

    return jwtDecode(token);
  } catch (_error) {
    console.error('âŒ Erreur lors du dÃ©codage du token:', error);
    removeToken();
    return null;
  }
};

// Utilitaire pour nettoyer complÃ¨tement l'authentification
export const clearAuth = () => {
  console.log('ğŸ§¹ Nettoyage complet de l\'authentification...');
  removeToken();
  // Nettoyer d'autres donnÃ©es d'auth si nÃ©cessaire
  localStorage.removeItem('user');
  localStorage.removeItem('authTimestamp');
};

// Utilitaire pour gÃ©nÃ©rer un token de mock valide (pour les tests)
export const generateMockToken = (userId = 'user-1', expirationHours = 24) => {
  return createValidMockToken(userId);
};